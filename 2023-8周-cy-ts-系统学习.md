# ts 系统学习

### ts 的配置

webpack 配置

### 1.ts 的基本类型

- [基本类型](基本类型)
  - [布尔型(boolean)](#布尔型boolean)
  - [数值型(number)](#数值型number)
  - [字符串(string)](#字符串string)
  - [数组](#数组)
  - [元组](#元组) 元组是固定长度的数组，其中的元素类型是已知的
  - [枚举](#枚举)
  - [Unknown](#unknown)
  - [any](#any)
  - [void](#void)
  - [null and undefined](#null-and-undefined)
  - [never](#never)
  - [object](#object)
  - [类型断言](#类型断言)
  - [关于 Number, String, Boolean, Symbol and Object](#关于number-string-boolean-symbol-and-object)

#### undefined

修改 undefined 类型的值：（联合类型）
let aa: number| undefined | null = null;
aa = 1

#### void

// void 类型 没有返回值的 类型

```ts
void 0;
function warnUser(): void {
  console.log('This is my warning message');
}
```

#### never

错误类型，不会返回类型

#### 枚举

作为对 JavaScript 的补充，枚举类型更适合给**数值型集合**命名

```ts
enum Color {
  Red = 1,
  Green,
  Blue = Math.floor(1.23),
  a // after computed must 赋值.(1061)
}
let c: Color = Color.Green;

console.error(Color["2"]) // Green

const 声明，不用被编译，
```

反向赋值

### 2.接口

约束函数，对象的类型

```ts
interface StringArray {
  [index: number]: string;
}

let chats: StringArray = ['A', 'B'];

interface Names {
  [x: string]: any; // 字符串索引
  [index: number]: string; // 数字索引
}
// eg:
let aab: Names = { a: 'a1', b: 'b1', 2: 'c2' };
console.error(aab[2]);

// 函数接口
type Add = (x: number, y: number) => number;

// 混合类型
interface Lib {
  (): void;
  version: string;
  doSomeThing(): void;
}

// 类
// 学习ts类之后，讲解
```

#### 接口，函数

```ts
interface add4 {
  (x: number, y: number): number;
}
// declare声明的类型或者变量或者模块，在include包含的文件范围内，都可以直接引用而不用去import或者import type相应的变量或者类型
declare function getSmallPet(): add4;
function pet(x: number, y: number) {
  return x + y;
}

pet(1, 2);

// 函数重载
function add8(...rest: number[]): number;
function add8(...rest: number[]): string;
function add8(...rest: any[]): any {
  let first = rest[0];
  if (typeof first === 'string') {
    return rest.join(',');
  }
  if (typeof first === 'number') {
    return rest.reduce((pre, cur) => pre + cur);
  }
}

console.error(add8(1, 2, 3, 4, 5)); // 10
console.error(add8('a1', '2', '3', '4')); // "a1,2,3,4"
```

#### 类

```ts
// 没意思，先省略
```

#### 泛型

对前端是一个比较新的概念，在高级类型中有很多应用。

泛型的好处：

1. 函数和类轻松支持多种类型
2. 不比写多条函数重载，和冗长的联合类型
3. 灵活的控制类型直接的约束

// 泛型 不确定数据类型。log<T> 可以用到接口中
// 背景 any 容易丢失类型

```ts
function log<T>(value: T): T {
  console.log(value);
  return value;
}

log<string[]>(['a', 'b']);
log(['a', 'b']);

// 泛型函数。
// 类型别名 type
// type Log = <T>(value: T)=>T;
// let mylog: Log = log;

// 泛型接口。 T就是一个泛型，实现时必须指定一个类型
interface Log<T> {
  <T>(value: T): T;
}
let myLog: Log<number> = log;

// 泛型相当于是一个参数，参数是类型

// 泛型约束
// 继承接口 ==》
class Log<T> {
  run(value: T) {
    console.log(value);
    return value;
  }
}

interface Length {
  length: number;
}

function logf<T extends Length>(value: T): T {
  console.log(value, value.length);
  return value;
}

logf('asdf'); // 参数有 length 属性即可。
```
