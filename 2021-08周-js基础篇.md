# js 基础篇

## 类型
```javascript
function test(person) {
  person.age = 17;
  person = { // person变成了另一块内存空间的地址
    name: '8',
    age: 8
  };
  return person;
}
const p1 = {
  name: '9',
  age: 9
};
const p2 = test(p1);
console.log(p1);
console.log(p2);

// p1：{name: “9”, age: 17}
// p2：{name: “8”, age: 8}

```

    null是对象吗？为什么？
    结论: null不是对象。

    0.1+0.2为什么不等于0.3？ 
    0.1和0.2在转换成二进制后会无限循环，多余的位数会被截掉，此时就已经出现了精度的损失

    BigInt('9007199254740995'); // Symbol和BigInt 不能 new


    typeof console.log; // 'function'

    'str' instanceof String; // false => str只是一个以string为数据类型的值，但并不属于String对象的实例

```javascript
let strobj = new String('bbb');
console.log(strobj instanceof String); // true
// 最准确的判断类型方法
Object.prototype.toString.call('111');
```

## 类型转换
JS中类型转换有哪几种？
    只有三种：

    转换成布尔值
    转换成字符串
    转换成数字
    
主要是 == 这种非严格等于，尽量少用。

    {a: 1} == true;//false
    {a: 1} == "[object Object]";//true
搞懂toString()与valueOf()的区别

## 闭包
闭包就是能读取其他函数内部变量的函数。
1. 读取内部变量。
2. 变量始终保存在内存当中。
```javascript 
var a = 1;function f1() {
  var a = 2
  function f2() {
    console.log(a);//2
  }
  return f2;
}
var x = f1();
x(); // 2
```
在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。

```javascript
for(var i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i) // 都是6
  }, 0)
}
```
为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好)
因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。（和react里面的定时器一样唉）  

解决方法：
1. let let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:
```javascript
// i = 1
{
  setTimeout(function timer(){
    console.log(1)
  },0)
}
// i = 2
{
  setTimeout(function timer(){
    console.log(2)
  },0)
}
// i = 3
...
```
2. 自执行保存
```javascript
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
```

3. 给定时器传入第三个参数, 作为timer函数的第一个函数参数
```javascript
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(j)
  }, 0, i)
}
```

## 原型和继承
第五种(最推荐使用): 组合继承的优化1
```javascript
  function Parent () {
    this.name = 'parent';
    this.play = [1, 2, 3];
  }
  function Child() {
    Parent.call(this); // 1
    this.type = 'child';
  }
  Child.prototype = Object.create(Parent.prototype); // 2
  Child.prototype.constructor = Child; // 3
```

es6 其实也是用了这个。

## 参考


[js 基础-神三元](https://juejin.cn/post/6844903974378668039)
